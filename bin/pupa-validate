#!/usr/bin/env node

var fs = require('fs')
  , path = require('path');

var uniq = require('lodash.uniq')
  , async = require('async')
  , cli = require('cli').enable('status')
  , request = require('request')
  , JSONStream = require('JSONStream')
  , JSV = require('jsv').JSV;

// Maps "_type" values of JSON documents to JSON Schema URLs.
var type_url_map = {};
// Maps URLs to parsed JSON representations of JSON Schema.
var url_json_map = {};
// Maps URLs to JSV JSONSchema objects.
var url_schema_map = {};

var env = JSV.createEnvironment(); // "strict" is slower
env.setOption('defaultSchemaURI', 'http://json-schema.org/draft-03/schema#');
var default_schema = env.getDefaultSchema();

// Returns all non-local references within a schema that have not yet been resolved.
var get_references = function(json) {
  var key, value, references = [];
  if (Object.prototype.toString.call(json) === '[object Object]') {
    for (key in json) {
      if (json.hasOwnProperty(key)) {
        value = json[key];
        if (value.$ref && !(value.$ref in url_json_map) && value.$ref[0] !== '#') {
          references.push(value.$ref);
        }
        references = references.concat(get_references(value));
      }
    }
  }
  return references;
};

// Registers schemas with JSV.
var register_schemas = function(urls, callback) {
  // Queue the HTTP requests to send in parallel.
  var queue = [];
  urls.forEach(function(url) {
    queue.push(function(notify) {
      var parser = JSONStream.parse();
      parser.on('data', function(json) {
        url_json_map[url] = json;
        url_schema_map[url] = env.createSchema(json, default_schema, url);
        notify(null); // notify async that the process is done
      });
      cli.info("GET " + url);
      request(url).pipe(parser);
    });
  });

  // Breadth-first search the schemas for references.
  async.parallel(queue, function() {
    var _i, _len, argument = [];
    for (_i = 0, _len = urls.length; _i < _len; _i++) {
      argument = argument.concat(get_references(url_json_map[urls[_i]]));
    }
    if (argument.length) {
      register_schemas(uniq(argument), callback);
    }
    else { // We're at maximum depth.
      callback();
    }
  });
};

var validate = function(data) {
  var instance_json = JSON.parse(data);
  var type = instance_json._type;
  if (type) {
    var url = type_url_map[type];
    if (url) {
      var schema = url_schema_map[url];
      if (schema) {
        var errors = schema.validate(instance_json).errors;
        if (errors.length) {
          cli.error(JSON.stringify(errors));
        }
      }
      else {
        cli.error("No schema for " + url);
      }
    }
    else {
      cli.error("No URL for " + type);
    }
  }
  else {
    cli.error("No _type for " + data);
  }
};

// Finish and print the report.
var finish = function() {
  report.end = new Date();
  report.time = (report.end.getTime() - report.start.getTime()) / 1000.0;
  cli.info(JSON.stringify(report));
  process.exit();
};

// Configure the option parser.
cli.setUsage('pupa-validate [OPTIONS] [TYPE URI ...]');
cli.width = 100;
cli.option_width = 30;
cli.parse({
  output_dir: ['o', 'The directory or Redis address (e.g. redis://localhost:6379/0) from which to read JSON documents', 'string', path.join(process.cwd(), 'scraped_data')]
});

var report = {};

cli.main(function(args, options) {
  report.start = new Date();
  report.plan = {
    options: options,
    arguments: args
  };

  var _i, _len, urls = [];
  for (_i = 0, _len = args.length; _i < _len; _i += 2) {
    type_url_map[args[_i]] = args[_i + 1];
    urls.push(args[_i + 1]);
  }

  register_schemas(urls, function() {
    var matches = options.output_dir.match(/^redis:\/\/([^\/:]+)?(?::(\d+))?(?:\/(\d+))?$/);
    if (matches) {
      var redis = require('redis');

      if (matches[1] == null) {
        matches[1] = '127.0.0.1';
      }
      if (matches[2] == null) {
        matches[2] = '6379';
      }
      if (matches[3] == null) {
        matches[3] = '0';
      }

      var client = redis.createClient(matches[2], matches[1]);

      client.select(matches[3], function() {
        client.keys('*', function($, keys) {
          client.mget(keys, function($, documents) {
            var _i, _len;
            for (_i = 0, _len = documents.length; _i < _len; _i++) {
              validate(documents[_i]);
            }
            finish();
          });
        });
      });
    }
    else {
      var glob = require('glob');

      // The asynchronous version runs slower and requires graceful-fs.
      glob('*.json', {
        cwd: options.output_dir
      }, function($, files) {
        var _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          validate(fs.readFileSync(path.join(options.output_dir, files[_i])));
        }
        finish();
      });
    }
  });
});
